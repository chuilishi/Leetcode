# 正则表达式

### ?

前面的字符可以出现**一次或零次**

bottom?n?    : bottom, botton都能匹配

### *

前面的字符可以出现**零次或多次**

abbbbbc  用ab?c无法匹配  用ab*c可以匹配

### +

前面的字符可以出现**一次或多次**

( 至少一次 )

ab+c    不能匹配ac  b要出现至少一次

### {min,max}

限定次数几次到几次

ap{2,5}le

匹配apple到appppple

{3,} 3次或以上

### ()

你的操作对象是多个字符

badbadbadapple

(**bad**){,3}apple   这样匹配

### |

或运算符

a ( wrong|error ){1,}

a wrong或者a error都可以

### []

[abc] 相当于 ( a|b|c )

[a-r] 从a到r的小写字符

[a-zA-Z0-9] 所有的字母,数字

### ^

[^0-9] 所有的非数字字符

[^a-z] 所有的除了小写字母的字符

### 行首行尾

^a  只匹配行首的a

a$ 只匹配行尾的a

**^{20}$** :含有20个字符的单词

### 元字符

大多以反斜杠\开头

| 元字符 | 含义                                    |
| ------ | --------------------------------------- |
| \      | 转义字符,后面接特殊符号( 类似\ \表示\ ) |
| \s     | 空白,Tab,换行符                         |
| \d     | 数字                                    |
| \w     | 英文字符,数字,上下划线                  |
| \D     | 非数字                                  |
| \W     | 非英文                                  |
| \S     | 非空白                                  |
| .      | 任意字符(不包含换行符)                  |
| \b     | 单词的边界,代表截断(如\w+\b 匹配单词)   |
|        |                                         |

### 选择的部分

括号内的内容就是自己选的东西

可以先将不要的内容选出来,然后括号自己想要的部分

\d*()      这里先将前面的所有数字都填了



### 思考方式

从头开始,在每个位置都判断一次可能性, 将每种可能都涵盖进去,造一个句子,类似:

前面的全选了,加上一个可选的字母,加上3到6个xxx,加上.....

将上面的这些东西抽象为一个句子:

? :可选的 





### Python中的使用

re库

先设置一个pattern:

```
pattern = re.compile('正则表达式')
```

然后在string 中 find:

```
items = re.findall(pattern, string)
```